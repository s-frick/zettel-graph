{
  "nodes": [
    {
      "id": "20251209-001700",
      "title": "Common Lisp – Zettelkasten Index",
      "summary": "Dieses Index-File sammelt alle bisherigen Common-Lisp-Zettel und ordnet sie thematisch.",
      "tags": [
        "commonlisp",
        "index"
      ],
      "group": "commonlisp",
      "size": 5,
      "file": "20251209-001700_clisp.md",
      "refs": [
        {
          "text": "S-Expressions: Listen & Atome",
          "href": "./20251210-130001_s-expressions-lists-atoms.md",
          "file": "20251210-130001_s-expressions-lists-atoms.md",
          "targetId": "20251210-130001"
        },
        {
          "text": "Zahlen in Common Lisp",
          "href": "./20251210-130002_numbers-clisp.md",
          "file": "20251210-130002_numbers-clisp.md",
          "targetId": "20251210-130002"
        },
        {
          "text": "Strings in Common Lisp",
          "href": "./20251210-130003_string-clisp.md",
          "file": "20251210-130003_string-clisp.md",
          "targetId": "20251210-130003"
        },
        {
          "text": "Symbole in Common Lisp",
          "href": "./20251210-130004_symbols-clisp.md",
          "file": "20251210-130004_symbols-clisp.md",
          "targetId": "20251210-130004"
        },
        {
          "text": "Beispiele zusammengesetzter S-Expressions",
          "href": "./20251210-130005_nested-s-expressions-clisp.md",
          "file": "20251210-130005_nested-s-expressions-clisp.md",
          "targetId": "20251210-130005"
        },
        {
          "text": "Property Lists (Plists)",
          "href": "./20251209-001800_property-lists-clisp.md",
          "file": "20251209-001800_property-lists-clisp.md",
          "targetId": "20251209-001800"
        },
        {
          "text": "`defvar` und globale dynamische Variablen",
          "href": "./20251209-085400_defvar-clisp.md",
          "file": "20251209-085400_defvar-clisp.md",
          "targetId": "20251209-085400"
        },
        {
          "text": "`push` und Listenmutation",
          "href": "./20251209-085500_push-list-clisp.md",
          "file": "20251209-085500_push-list-clisp.md",
          "targetId": "20251209-085500"
        },
        {
          "text": "`dolist` – Listeniteration",
          "href": "./20251209-085900_dolist-clisp.md",
          "file": "20251209-085900_dolist-clisp.md",
          "targetId": "20251209-085900"
        },
        {
          "text": "`format` mit ~{ ... ~} und Listenformatierung",
          "href": "./20251209-090400_format-lists.clisp.md",
          "file": "20251209-090400_format-lists.clisp.md",
          "targetId": "20251209-090400"
        },
        {
          "text": "`with-open-file` und Datei-IO",
          "href": "./20251209-091201_with-open-file-clisp.md",
          "file": "20251209-091201_with-open-file-clisp.md",
          "targetId": "20251209-091201"
        },
        {
          "text": "`lambda`, `#'` und Funktionsobjekte",
          "href": "./20251209-091200_higher-order-fn.clisp.md",
          "file": "20251209-091200_higher-order-fn.clisp.md",
          "targetId": "20251209-091200"
        },
        {
          "text": "Keyword-Parameter (`&key`)",
          "href": "./20251209-091500_keyword-param-clisp.md",
          "file": "20251209-091500_keyword-param-clisp.md",
          "targetId": "20251209-091500"
        },
        {
          "text": "`&rest` in Parameterlisten und Bezug zu anderen &-Schaltern",
          "href": "./20251210-080300_rest-parameterlist-clisp.md",
          "file": "20251210-080300_rest-parameterlist-clisp.md",
          "targetId": "20251210-080300"
        },
        {
          "text": "Code als Daten: Ausdrücke programmatisch bauen",
          "href": "./20251210-080100_code-as-data.md",
          "file": "20251210-080100_code-as-data.md",
          "targetId": "20251210-080100"
        },
        {
          "text": "Backquote, `,` (unquote) und `,@` (unquote-splicing)",
          "href": "./20251210-080200_backquote-unquote-comma-at-clisp.md",
          "file": "20251210-080200_backquote-unquote-comma-at-clisp.md",
          "targetId": "20251210-080200"
        },
        {
          "text": "Einfaches Macro-Beispiel: `where`",
          "href": "./20251210-080400_simple-where-macro-clisp.md",
          "file": "20251210-080400_simple-where-macro-clisp.md",
          "targetId": "20251210-080400"
        }
      ],
      "raw": "---\nID: 20251209-001700\nTAGS: commonlisp, index\n---\n# Common Lisp – Zettelkasten Index\n\nDieses Index-File sammelt alle bisherigen Common-Lisp-Zettel und ordnet sie thematisch.\n\n- Grundsyntax\n  - [S-Expressions: Listen & Atome](./20251210-130001_s-expressions-lists-atoms.md)\n  - [Zahlen in Common Lisp](./20251210-130002_numbers-clisp.md)\n  - [Strings in Common Lisp](./20251210-130003_string-clisp.md)\n  - [Symbole in Common Lisp](./20251210-130004_symbols-clisp.md)\n  - [Beispiele zusammengesetzter S-Expressions](./20251210-130005_nested-s-expressions-clisp.md)\n- Datenstrukturen\n  - [Property Lists (Plists)](./20251209-001800_property-lists-clisp.md)\n- Variablen & Zustand\n  - [`defvar` und globale dynamische Variablen](./20251209-085400_defvar-clisp.md)\n  - [`push` und Listenmutation](./20251209-085500_push-list-clisp.md)\n- Iteration & Kontrolle\n  - [`dolist` – Listeniteration](./20251209-085900_dolist-clisp.md)\n- Ein-/Ausgabe & Formatierung\n  - [`format` mit ~{ ... ~} und Listenformatierung](./20251209-090400_format-lists.clisp.md)\n  - [`with-open-file` und Datei-IO](./20251209-091201_with-open-file-clisp.md)\n- Funktionen & Higher-Order-Programmierung\n  - [`lambda`, `#'` und Funktionsobjekte](./20251209-091200_higher-order-fn.clisp.md)\n  - [Keyword-Parameter (`&key`)](./20251209-091500_keyword-param-clisp.md)\n  - [`&rest` in Parameterlisten und Bezug zu anderen &-Schaltern](./20251210-080300_rest-parameterlist-clisp.md)\n- Macros & Code als Daten\n  - [Code als Daten: Ausdrücke programmatisch bauen](./20251210-080100_code-as-data.md)\n  - [Backquote, `,` (unquote) und `,@` (unquote-splicing)](./20251210-080200_backquote-unquote-comma-at-clisp.md)\n  - [Einfaches Macro-Beispiel: `where`](./20251210-080400_simple-where-macro-clisp.md)\n"
    },
    {
      "id": "20251209-001800",
      "title": "Property Lists (Plists) in Common Lisp",
      "summary": "",
      "tags": [
        "commonlisp",
        "plist"
      ],
      "group": "commonlisp",
      "size": 5,
      "file": "20251209-001800_property-lists-clisp.md",
      "refs": [],
      "raw": "---\nID: 20251209-001800\nTAGS: commonlisp, plist\n---\n# Property Lists (Plists) in Common Lisp\n\n## Konzept\n\nEine Property List (plist) ist eine einfache Liste aus Schlüssel–Wert-Paaren, meist mit Keywords.\n\n## Beispiel\n\n```lisp\n(list :a 1 :b 2 :c 3)\n;; => (:A 1 :B 2 :C 3)\n```\n\n## Zugriff\n\n```lisp\n(getf (list :a 1 :b 2 :c 3) :c)\n;; => 3\n```\n\n## Merkpunkte\n\n- Plists bestehen aus alternierenden Keys und Values.\n- Zugriff erfolgt über `getf`.\n- Flexibel und dynamisch, aber ohne Typsicherheit.\n"
    },
    {
      "id": "20251209-085400",
      "title": "`defvar` - globale dynamische Variable",
      "summary": "",
      "tags": [
        "commonlisp",
        "variables",
        "dynamic-scope"
      ],
      "group": "commonlisp",
      "size": 5,
      "file": "20251209-085400_defvar-clisp.md",
      "refs": [],
      "raw": "---\nID: 20251209-085400\nTAGS: commonlisp, variables, dynamic-scope\n---\n\n# `defvar` - globale dynamische Variable\n\n## Konzept\n\n`defvar` definiert eine *dynamische* globale Variable, die nur initialisiert wird, wenn sie zuvor ungebunden war.\n\n## Beispiel\n```lisp\n(defvar *db* nil)\n```\n\n## Verhalten\n- definiert eine global sichtbare Variable\n- dynamisch gebunden (nicht lexikalisch!)\n- erneutes `defvar` überschreibt den Wert nicht\n\n## Merkpunkte\n- dynamischer SCope ist ein wichtiges Konzept in COmmon Lisp\n- Globale Variablen werden traditionell (Konvention) mit Sternchen benannt: `*variable*`\n"
    },
    {
      "id": "20251209-085500",
      "title": "`push` - Einfügen an den Anfang einer Liste",
      "summary": "",
      "tags": [
        "commonlisp",
        "lists",
        "mutation"
      ],
      "group": "commonlisp",
      "size": 5,
      "file": "20251209-085500_push-list-clisp.md",
      "refs": [],
      "raw": "---\nID: 20251209-085500\nTAGS: commonlisp, lists, mutation\n---\n\n# `push` - Einfügen an den Anfang einer Liste\n\n## Konzept\n`push` fügt einen Weret an den Anfang einer LIste ein und modifiziert die BIndung einer Variable.\n\n## Beispiel\n\n```lisp\n(defvar *items* nil)\n(push 10 *items*)\n(push 20 *items*)\n*items*\n;; => (20 10)\n```\n## Funktionsweise\n`push` entspricht:\n\n```lisp\n(setf *items* (cons 20 *items*))\n```\n\n## Merkpunkte\n- mutiert die gebundene Variable\n- fügt immer vorne ein (Stack-artiges Verhalten)\n- funktioniert nur mit Variablen, nicht mit Ausdrücken\n"
    },
    {
      "id": "20251209-085900",
      "title": "`dolist` - Listeniteration",
      "summary": "",
      "tags": [
        "commonlisp",
        "lists",
        "iteration"
      ],
      "group": "commonlisp",
      "size": 5,
      "file": "20251209-085900_dolist-clisp.md",
      "refs": [],
      "raw": "---\nID: 20251209-085900\nTAGS: commonlisp, lists, iteration\n---\n\n# `dolist` - Listeniteration\n\n## Konzept\n\n`dolist` iteriert nacheinander über die Elemente einer Liste und führt einen Block Code darauf aus.\n\n## Beispiel\n\n```lisp\n(dolist (x '(1 2 3))\n    (format t \"~a \" x))\n;; Ausgabe: 1 2 3\n```\n\n## Rückgabewert\n\n`dolist` gibt standardmäßig `nil` zurueck,\n es sei denn, ein alternativer Rückgabewert wird angegeben:\n\n```lisp\n(dolist (x '(1 2 3) 'done)\n    (print x))\n;; => DONE\n```\n\n## Merkpunkte\n\n- einfache Listeniteration\n- Bindet die SChleifenvariable nacheinander an jedes Element\n- optionaler Return-Wert moeglich\n"
    },
    {
      "id": "20251209-090400",
      "title": "20251209-090400_format-lists.clisp.md",
      "summary": "",
      "tags": [
        "commonlisp",
        "formatting",
        "io"
      ],
      "group": "commonlisp",
      "size": 5,
      "file": "20251209-090400_format-lists.clisp.md",
      "refs": [],
      "raw": "---\nID: 20251209-090400\nTAGS: commonlisp, formatting, io\n---\n\n## Konzept\n`~{ ... ~}` iteriert automatisch ueber eien Sequenz und formatiert jedes Element gemaess dem enthaltenen Formatstring.\n\n```lisp\n(format t \"~{~a ~}\" '(1 2 3))\n;; Ausgabe: 1 2 3\n```\n\n## Anwendung auf Key/Value-Paare\n\n```lisp\n(format t \"~{~a: ~a~%~}\" '(:title \"Kind of Blue\" :artist \"Miles Davis\"))\n;; Ausgabe:\n;; TITLE: Kind of Blue\n;; ARTIST: Miles Davis\n```\n\n## Merkpunkte\n- wiederholt  das Format fuer jedes Element bzw. Elementpaar\n- sehr maechtig fuer strukturierte Ausgaben\n- funktioniert auf allen Sequenzen\n"
    },
    {
      "id": "20251209-091200",
      "title": "Funktionsobjekte: `lambda`, `#'`, Higher-Order Functions",
      "summary": "",
      "tags": [
        "commonlisp",
        "functions",
        "higherorder"
      ],
      "group": "commonlisp",
      "size": 5,
      "file": "20251209-091200_higher-order-fn.clisp.md",
      "refs": [
        {
          "text": "Keyword-Parameter (`&key`)",
          "href": "./20251209-091500_keyword-param-clisp.md",
          "file": "20251209-091500_keyword-param-clisp.md",
          "targetId": "20251209-091500"
        }
      ],
      "raw": "---\nID: 20251209-091200\nTAGS: commonlisp, functions, higherorder\n---\n# Funktionsobjekte: `lambda`, `#'`, Higher-Order Functions\n\n## Konzept\n\nLisp behandelt Funktionen als First-Class-Objekte; sie können erzeugt, gespeichert und übergeben werden.\n\n## Beispiel: Lambda-Ausdruck\n\n```lisp\n(mapcar #'(lambda (x) (* x x))\n        '(1 2 3))\n;; => (1 4 9)\n```\n\n## Bedeutung von `#'`\n\n`#'` ist `(function …)` und dient der Funktionsquote:\n\n```lisp\n#'(lambda (x) x)\n;; ist äquivalent zu\n(function (lambda (x) x))\n```\n\n## Closure-Beispiel\n\n```lisp\n(defun make-adder (n)\n  #'(lambda (x) (+ x n)))\n\n(funcall (make-adder 10) 5)\n;; => 15\n```\n\n## Merkpunkte\n\n- Funktionen sind erstklassige Werte  \n- Lambdas erzeugen anonyme Funktionen  \n- Closures „merken“ sich ihre Umgebung  \n- `mapcar`, `remove-if`, `sort` usw. nutzen Functions als Argumente\n\n## Siehe auch\n\n- [Keyword-Parameter (`&key`)](./20251209-091500_keyword-param-clisp.md)\n\n"
    },
    {
      "id": "20251209-091201",
      "title": "`with-open-file` – Dateien lesen und schreiben",
      "summary": "",
      "tags": [
        "commonlisp",
        "io",
        "file"
      ],
      "group": "commonlisp",
      "size": 5,
      "file": "20251209-091201_with-open-file-clisp.md",
      "refs": [
        {
          "text": "`Property Lists (Plists)`",
          "href": "./20251209-001800_property-lists-clisp.md",
          "file": "20251209-001800_property-lists-clisp.md",
          "targetId": "20251209-001800"
        },
        {
          "text": "`defvar` – globale dynamische Variablen",
          "href": "./20251209-085400_defvar-clisp.md",
          "file": "20251209-085400_defvar-clisp.md",
          "targetId": "20251209-085400"
        }
      ],
      "raw": "---\nID: 20251209-091201\nTAGS: commonlisp, io, file\n---\n# `with-open-file` – Dateien lesen und schreiben\n\n## Konzept\n\n`with-open-file` öffnet eine Datei und schließt sie nach Ende des Blocks automatisch.\n\n## Beispiel: Speichern eines Lisp-Objekts\n\n```lisp\n(with-open-file (out \"data.lisp\" :direction :output :if-exists :supersede)\n  (print '(:a 1 :b 2) out))\n```\n\n## Laden\n\n```lisp\n(with-open-file (in \"data.lisp\" :direction :input)\n  (read in))\n;; => (:A 1 :B 2)\n```\n\n## `with-standard-io-syntax`\n```lisp\n(with-open-file (in filename)\n  (with-standard-io-syntax\n    (setf *db* (read in))))\n```\n\n## Merkpunkte\n\n- `print` und `read` erzeugen Lisp-lesbares Format  \n- `with-standard-io-syntax` vermeidet Kompatibilitätsprobleme  \n- automatische Ressourcenschließung\n\n## Siehe auch\n\n- [`Property Lists (Plists)`](./20251209-001800_property-lists-clisp.md)\n- [`defvar` – globale dynamische Variablen](./20251209-085400_defvar-clisp.md)\n\n\n\n"
    },
    {
      "id": "20251209-091500",
      "title": "Keyword-Parameter (`&key`)",
      "summary": "",
      "tags": [
        "commonlisp",
        "functions",
        "keyword-parameters",
        "defaults",
        "supplied"
      ],
      "group": "commonlisp",
      "size": 5,
      "file": "20251209-091500_keyword-param-clisp.md",
      "refs": [
        {
          "text": "`lambda`, `#'` und Funktionsobjekte",
          "href": "./20251209-091200_higher-order-fn.clisp.md",
          "file": "20251209-091200_higher-order-fn.clisp.md",
          "targetId": "20251209-091200"
        }
      ],
      "raw": "---\nID: 20251209-091500\nTAGS: commonlisp, functions, keyword-parameters, defaults, supplied\n---\n# Keyword-Parameter (`&key`)\n\n## Konzept\n\nKeyword-Parameter erlauben benannte, optionale Argumente mit Default-Werten.\n\n## Beispiel\n\n```lisp\n(defun foo (&key a (b 20) (c 30 c-supplied-p))\n  (list a b c c-supplied-p))\n```\n\n## Aufrufe\n\n```lisp\n(foo :a 1 :c 5)\n;; => (1 20 5 T)\n\n(foo)\n;; => (NIL 20 30 NIL)\n```\n\n## Merkpunkte\n\n- Reihenfolge egal  \n- Default-Werte möglich  \n- `supplied-p` zeigt an, ob ein Parameter übergeben wurde  \n\n## Siehe auch\n\n- [`lambda`, `#'` und Funktionsobjekte](./20251209-091200_higher-order-fn.clisp.md)\n"
    },
    {
      "id": "20251210-080100",
      "title": "Code als Daten: Ausdrücke programmatisch bauen",
      "summary": "",
      "tags": [
        "commonlisp",
        "macros",
        "code-as-data"
      ],
      "group": "commonlisp",
      "size": 5,
      "file": "20251210-080100_code-as-data.md",
      "refs": [
        {
          "text": "Backquote, `,` und `,@`",
          "href": "./20251210-080200_backquote-unquote-comma-at-clisp.md",
          "file": "20251210-080200_backquote-unquote-comma-at-clisp.md",
          "targetId": "20251210-080200"
        },
        {
          "text": "Einfaches Macro-Beispiel: `where`",
          "href": "./20251210-080400_simple-where-macro-clisp.md",
          "file": "20251210-080400_simple-where-macro-clisp.md",
          "targetId": "20251210-080400"
        }
      ],
      "raw": "---\nID: 20251210-080100\nTAGS: commonlisp, macros, code-as-data\n---\n# Code als Daten: Ausdrücke programmatisch bauen\n\n## Konzept\n\nIn Common Lisp sind Code und Daten strukturell gleich (Listen).  \nMan kann daher **Ausdrücke als Daten erzeugen**, die später ausgewertet werden.\n\n## Beispiel: Vergleichsausdruck bauen\n\n```lisp\n(defun make-comparison-expr (field value)\n  `(equal (getf cd ,field) ,value))\n```\n\nAufruf:\n\n```lisp\n(make-comparison-expr :rating 10)\n;; => (EQUAL (GETF CD :RATING) 10)\n```\n\nDer Rückgabewert ist keine Zahl, sondern eine **Form** (eine Liste, die als Code gelesen werden kann).\n\n## Liste von Vergleichsausdrücken\n\n```lisp\n(defun make-comparisons-list (fields)\n  (loop while fields\n        collecting (make-comparison-expr (pop fields) (pop fields))))\n```\n\nBeispiel:\n\n```lisp\n(make-comparisons-list (list :rating 10 :title \"Title\"))\n;; => ((EQUAL (GETF CD :RATING) 10)\n;;     (EQUAL (GETF CD :TITLE) \"Title\"))\n```\n\n## Merkpunkte\n\n- Lisp-Code ist Daten (Listen), die man zusammensetzen kann.\n- Funktionen wie `make-comparison-expr` erzeugen **S-Expressions**, die später evaluiert oder von Macros genutzt werden.\n- Grundlage für Metaprogrammierung und Macros.\n\n## Siehe auch\n\n- [Backquote, `,` und `,@`](./20251210-080200_backquote-unquote-comma-at-clisp.md)\n- [Einfaches Macro-Beispiel: `where`](./20251210-080400_simple-where-macro-clisp.md)\n"
    },
    {
      "id": "20251210-080200",
      "title": "Backquote, `,` (unquote) und `,@` (unquote-splicing)",
      "summary": "",
      "tags": [
        "commonlisp",
        "macros",
        "syntax"
      ],
      "group": "commonlisp",
      "size": 5,
      "file": "20251210-080200_backquote-unquote-comma-at-clisp.md",
      "refs": [
        {
          "text": "Code als Daten: Ausdrücke programmatisch bauen",
          "href": "./20251210-080100_code-as-data.md",
          "file": "20251210-080100_code-as-data.md",
          "targetId": "20251210-080100"
        },
        {
          "text": "Einfaches Macro-Beispiel: `where`",
          "href": "./20251210-080400_simple-where-macro-clisp.md",
          "file": "20251210-080400_simple-where-macro-clisp.md",
          "targetId": "20251210-080400"
        }
      ],
      "raw": "---\nID: 20251210-080200\nTAGS: commonlisp, macros, syntax\n---\n# Backquote, `,` (unquote) und `,@` (unquote-splicing)\n\n## Konzept\n\nMit Backquote (`` ` ``) definiert man **Template-Listen**, in denen man Teile mit `,` (unquote) oder `,@` (unquote-splicing) einfügen kann.\n\n## Backquote & `,` (unquote)\n\n```lisp\n(let ((field :rating)\n      (value 10))\n  `(equal (getf cd ,field) ,value))\n;; => (EQUAL (GETF CD :RATING) 10)\n```\n\n- Die ganze Form steht unter Backquote: ``` `( ... ) ```  \n- `,field` wird durch den Wert von `field` ersetzt (`:rating`).  \n- `,value` wird durch `10` ersetzt.\n\n## `,@` (unquote-splicing)\n\n``,@`` „entpackt“ eine Liste und fügt ihre Elemente direkt in die umgebende Liste ein.\n\nBeispiel:\n\n```lisp\n(list 1 2 (list 3 4 5))\n;; => (1 2 (3 4 5))\n\n`(1 2 ,(list 3 4 5))\n;; => (1 2 (3 4 5))\n\n`(1 2 ,@(list 3 4 5))\n;; => (1 2 3 4 5)\n```\n\n- Mit `,` wird die Liste als **ein Element** eingefügt.\n- Mit `,@` werden die **Elemente der Liste** einzeln eingefügt.\n\n## Bezug zum Beispiel aus dem Buch\n\n```lisp\n`(and ,(list 1 2 3))\n;; => (AND (1 2 3))\n\n`(and ,@(list 1 2 3))\n;; => (AND 1 2 3)\n\n`(and ,@(list 1 2 3) 4)\n;; => (AND 1 2 3 4)\n```\n\n## Merkpunkte\n\n- Backquote = Template für auszuwertenden Code.\n- `,` = Wert an dieser Stelle einfügen.\n- `,@` = *Liste von Werten* an dieser Stelle „entpacken“.\n- Sehr wichtig für Macros, die Code zusammensetzen.\n\n## Siehe auch\n\n- [Code als Daten: Ausdrücke programmatisch bauen](./20251210-080100_code-as-data.md)\n- [Einfaches Macro-Beispiel: `where`](./20251210-080400_simple-where-macro-clisp.md)\n"
    },
    {
      "id": "20251210-080300",
      "title": "`&rest` in Parameterlisten und Bezug zu anderen `&`-Schaltern",
      "summary": "",
      "tags": [
        "commonlisp",
        "functions",
        "lambda-list"
      ],
      "group": "commonlisp",
      "size": 5,
      "file": "20251210-080300_rest-parameterlist-clisp.md",
      "refs": [
        {
          "text": "Keyword-Parameter (`&key`)",
          "href": "./20251209-091500-keyword-param-clisp.md",
          "file": "20251209-091500-keyword-param-clisp.md",
          "targetId": "20251209-091500"
        },
        {
          "text": "Funktionsobjekte und Macros",
          "href": "./20251209-091200-higher-order-fn.clisp.md",
          "file": "20251209-091200-higher-order-fn.clisp.md",
          "targetId": "20251209-091200"
        }
      ],
      "raw": "---\nID: 20251210-080300\nTAGS: commonlisp, functions, lambda-list\n---\n# `&rest` in Parameterlisten und Bezug zu anderen `&`-Schaltern\n\n## Konzept\n\n`&rest` in einer Parameterliste sammelt **beliebig viele Argumente** in eine Liste.\n\n## Basisbeispiel\n\n```lisp\n(defun collect-rest (&rest args)\n  args)\n\n(collect-rest 1 2 3)\n;; => (1 2 3)\n```\n\nHier nimmt `collect-rest` 0 bis n Argumente und packt sie in `args`.\n\n## Bezug zu anderen Lambda-Listen-Schaltern\n\nCommon Lisp kennt u. a.:\n\n- `&optional` – optionale Argumente mit Default-Wert  \n- `&rest` – restliche Argumente als Liste  \n- `&key` – benannte (Keyword-)Argumente  \n- `&aux` – zusätzliche lokale Variablen  \n\nBeispiel gemischt:\n\n```lisp\n(defun demo (a\n             &optional b\n             &rest rest\n             &key key1 key2)\n  (list a b rest key1 key2))\n```\n\n(so etwas ist in der Praxis eher aufgeteilt, aber zeigt die Idee)\n\n## `&rest` in Macros\n\nAuch Macros können `&rest` verwenden, um eine variable Anzahl von Formen entgegenzunehmen:\n\n```lisp\n(defmacro my-print-all (&rest forms)\n  `(progn\n     ,@(loop for f in forms\n             collect `(print ,f))))\n```\n\nAufruf:\n\n```lisp\n(my-print-all 1 (+ 1 2) \"hi\")\n;; expandiert grob zu:\n;; (PROGN (PRINT 1) (PRINT (+ 1 2)) (PRINT \"hi\"))\n```\n\n## Merkpunkte\n\n- `&rest` sammelt die restlichen (nicht anders gebundenen) Argumente in einer Liste.\n- In Macros sehr wichtig, um „Arbiträr viele Bedingungen / Formen“ zu akzeptieren.\n- Ergänzt `&optional` und `&key`:\n  - `&optional` → „einige wenige optionale Werte“\n  - `&rest` → „beliebig viele Werte“\n  - `&key` → „benannte optionale Werte“\n\n## Siehe auch\n\n- [Keyword-Parameter (`&key`)](./20251209-091500-keyword-param-clisp.md)\n- [Funktionsobjekte und Macros](./20251209-091200-higher-order-fn.clisp.md)\n"
    },
    {
      "id": "20251210-080400",
      "title": "Einfaches Macro-Beispiel: `where`",
      "summary": "",
      "tags": [
        "commonlisp",
        "macros",
        "where"
      ],
      "group": "commonlisp",
      "size": 5,
      "file": "20251210-080400_simple-where-macro-clisp.md",
      "refs": [
        {
          "text": "Code als Daten: Ausdrücke programmatisch bauen",
          "href": "./20251210-080100_code-as-data.md",
          "file": "20251210-080100_code-as-data.md",
          "targetId": "20251210-080100"
        },
        {
          "text": "Backquote, `,` und `,@`",
          "href": "./20251210-080200_backquote-unquote-comma-at-clisp.md",
          "file": "20251210-080200_backquote-unquote-comma-at-clisp.md",
          "targetId": "20251210-080200"
        },
        {
          "text": "`&rest` in Parameterlisten",
          "href": "./20251210-080300_rest-parameterlist-clisp.md",
          "file": "20251210-080300_rest-parameterlist-clisp.md",
          "targetId": "20251210-080300"
        }
      ],
      "raw": "---\nID: 20251210-080400\nTAGS: commonlisp, macros, where\n---\n# Einfaches Macro-Beispiel: `where`\n\n## Ziel\n\nEin Macro definieren, das eine einfache „WHERE“-ähnliche Filterfunktion erzeugt.  \nDie eigentliche Idee: **Macro + `&rest` + Backquote + `,@` kombinieren.**\n\n## Hilfsfunktionen (Code-Erzeugung)\n\n```lisp\n(defun make-comparison-expr (field value)\n  `(equal (getf cd ,field) ,value))\n\n(defun make-comparisons-list (fields)\n  (loop while fields\n        collecting (make-comparison-expr (pop fields) (pop fields))))\n```\n\n- `make-comparison-expr` baut `(equal (getf cd :field) value)`\n- `make-comparisons-list` baut eine Liste von solchen Expressions\n\n## Das Macro `where`\n\n```lisp\n(defmacro where (&rest clauses)\n  `#'(lambda (cd) (and ,@(make-comparisons-list clauses))))\n```\n\nAufruf-Beispiel:\n\n```lisp\n(where :title \"Give Us a Break\" :ripped t)\n;; Macroexpansion (grob):\n;; #'(LAMBDA (CD)\n;;     (AND (EQUAL (GETF CD :TITLE) \"Give Us a Break\")\n;;          (EQUAL (GETF CD :RIPPED) T)))\n```\n\n## Zusammenspiel der Bausteine\n\n- `&rest clauses`  \n  → alle übergebenen Argumente (z. B. `:title \"Give Us a Break\" :ripped t`) landen als Liste in `clauses`.\n\n- `make-comparisons-list`  \n  → erzeugt aus `clauses` eine Liste von `(equal (getf cd field) value)`-Forms.\n\n- Backquote + `,@`  \n\n```lisp\n`#'(lambda (cd) (and ,@(make-comparisons-list clauses)))\n```\n\n  - Backquote: Template für den resultierenden Code  \n  - `,@(make-comparisons-list clauses)` entpackt die Liste von Vergleichs-Forms direkt in das `and`:\n\n    - ohne `,@`: `(AND (EQUAL ...) (EQUAL ...))` wäre verschachtelt als Liste  \n    - mit `,@`: `(AND (EQUAL ...) (EQUAL ...))` als „flache“ AND-Form\n\n## Merkpunkte\n\n- Macros arbeiten auf **unexpandiertem Code** (Listen), nicht auf Werten.\n- `&rest` sammelt die „WHERE-Bedingungen“ in eine Liste.\n- Backquote + `,` + `,@` bilden ein Template-System für den erzeugten Code.\n- Das Macro erzeugt eine Funktion (`#'(lambda (cd) ...)`), die als Prädikat verwendet werden kann (z. B. mit `select`).\n\n## Siehe auch\n\n- [Code als Daten: Ausdrücke programmatisch bauen](./20251210-080100_code-as-data.md)\n- [Backquote, `,` und `,@`](./20251210-080200_backquote-unquote-comma-at-clisp.md)\n- [`&rest` in Parameterlisten](./20251210-080300_rest-parameterlist-clisp.md)\n"
    },
    {
      "id": "20251210-130001",
      "title": "S-Expressions: Listen und Atome",
      "summary": "",
      "tags": [
        "commonlisp",
        "syntax",
        "s-expressions"
      ],
      "group": "commonlisp",
      "size": 5,
      "file": "20251210-130001_s-expressions-lists-atoms.md",
      "refs": [
        {
          "text": "Zahlen in Common Lisp",
          "href": "./20251210-130002_numbers-clisp.md",
          "file": "20251210-130002_numbers-clisp.md",
          "targetId": "20251210-130002"
        },
        {
          "text": "Strings in Common Lisp",
          "href": "./20251210-130003_string-clisp.md",
          "file": "20251210-130003_string-clisp.md",
          "targetId": "20251210-130003"
        },
        {
          "text": "Symbole in Common Lisp",
          "href": "./20251210-130004_symbols-clisp.md",
          "file": "20251210-130004_symbols-clisp.md",
          "targetId": "20251210-130004"
        }
      ],
      "raw": "---\nID: 20251210-130001\nTAGS: commonlisp, syntax, s-expressions\n---\n# S-Expressions: Listen und Atome\n\n## Konzept\n\nEine S-Expression ist entweder:\n\n- **ein Atom**  \n- **eine Liste** (in Klammern, whitespace-getrennt)\n\nDieses einfache Schema beschreibt die gesamte syntaktische Struktur von Common Lisp.\n\n## Listen\n\n```lisp\n(x 1 \"foo\")\n(+ (* 2 3) 4)\n```\n\nListen können verschachtelt sein und bilden **Baumstrukturen**.\n\n## Atome\n\nAtome sind alle nicht-listigen Objekte:  \nSymbole, Zahlen, Strings, Characters, Keywords usw.\n\n## Kommentare\n\nBeginnen mit `;` und laufen bis zum Zeilenende.\n\n## Siehe auch\n\n- [Zahlen in Common Lisp](./20251210-130002_numbers-clisp.md)  \n- [Strings in Common Lisp](./20251210-130003_string-clisp.md)  \n- [Symbole in Common Lisp](./20251210-130004_symbols-clisp.md)\n"
    },
    {
      "id": "20251210-130002",
      "title": "Zahlen in Common Lisp",
      "summary": "",
      "tags": [
        "commonlisp",
        "numbers",
        "syntax"
      ],
      "group": "commonlisp",
      "size": 5,
      "file": "20251210-130002_numbers-clisp.md",
      "refs": [
        {
          "text": "S-Expressions: Listen & Atome",
          "href": "./20251210-130001_s-expressions-lists-atoms.md",
          "file": "20251210-130001_s-expressions-lists-atoms.md",
          "targetId": "20251210-130001"
        },
        {
          "text": "Symbole in Common Lisp",
          "href": "./20251210-130004_symbols-clisp.md",
          "file": "20251210-130004_symbols-clisp.md",
          "targetId": "20251210-130004"
        }
      ],
      "raw": "---\nID: 20251210-130002\nTAGS: commonlisp, numbers, syntax\n---\n# Zahlen in Common Lisp\n\n## Konzept\n\nZahlensyntax in Common Lisp ist flexibel. Der Reader erkennt:\n\n- **Integer**\n- **Rationals**\n- **Floats (verschiedener Präzision)**\n\n## Beispiele\n\n```lisp\n123\n3/7\n1.0\n1.0e0\n1.0d0\n-1/4\n246/2\n```\n\n## Wichtige Eigenschaften\n\n- Rationale Zahlen werden **automatisch gekürzt**  \n  → `-2/8` wird zu `-1/4`, `246/2` wird zu `123`.\n- Floats unterscheiden sich durch Präzision:  \n  `1.0` ≠ `1.0d0` ≠ `1`\n\n## Siehe auch\n\n- [S-Expressions: Listen & Atome](./20251210-130001_s-expressions-lists-atoms.md)\n- [Symbole in Common Lisp](./20251210-130004_symbols-clisp.md)\n"
    },
    {
      "id": "20251210-130003",
      "title": "Strings in Common Lisp",
      "summary": "",
      "tags": [
        "commonlisp",
        "strings",
        "syntax"
      ],
      "group": "commonlisp",
      "size": 5,
      "file": "20251210-130003_string-clisp.md",
      "refs": [
        {
          "text": "Symbole in Common Lisp",
          "href": "./20251210-130004_symbols-clisp.md",
          "file": "20251210-130004_symbols-clisp.md",
          "targetId": "20251210-130004"
        },
        {
          "text": "S-Expressions",
          "href": "./20251210-130001_s-expressions-lists-atoms.md",
          "file": "20251210-130001_s-expressions-lists-atoms.md",
          "targetId": "20251210-130001"
        }
      ],
      "raw": "---\nID: 20251210-130003\nTAGS: commonlisp, strings, syntax\n---\n# Strings in Common Lisp\n\n## Konzept\n\nStrings sind Sequenzen aus Zeichen, eingeschlossen in **\"...\"**.\n\n## Escapes\n\n```lisp\n\"foo\"\n\"fo\\o\"\n\"fo\\\\o\"\n\"fo\\\"o\"\n```\n\nNur zwei Zeichen *müssen* escaped werden:\n\n- `\"` → escaped als `\\\"`\n- `\\` → escaped als `\\\\`\n\nAlle anderen Zeichen sind erlaubt.\n\n## Merkpunkte\n\n- Strings sind unveränderliche Sequenzen (immutable).\n- Reader verarbeitet Escapes beim Einlesen.\n\n## Siehe auch\n\n- [Symbole in Common Lisp](./20251210-130004_symbols-clisp.md)\n- [S-Expressions](./20251210-130001_s-expressions-lists-atoms.md)\n\n"
    },
    {
      "id": "20251210-130004",
      "title": "Symbole in Common Lisp",
      "summary": "",
      "tags": [
        "commonlisp",
        "symbols",
        "syntax",
        "reader",
        "packages"
      ],
      "group": "commonlisp",
      "size": 5,
      "file": "20251210-130004_symbols-clisp.md",
      "refs": [
        {
          "text": "Strings in Common Lisp",
          "href": "./20251210-130003_string-clisp.md",
          "file": "20251210-130003_string-clisp.md",
          "targetId": "20251210-130003"
        },
        {
          "text": "Zahlen in Common Lisp",
          "href": "./20251210-130002_numbers-clisp.md",
          "file": "20251210-130002_numbers-clisp.md",
          "targetId": "20251210-130002"
        }
      ],
      "raw": "---\nID: 20251210-130004\nTAGS: commonlisp, symbols, syntax, reader, packages\n---\n# Symbole in Common Lisp\n\n## Konzept\n\nSymbole repräsentieren Namen im Programm:\n\n- Variablen\n- Funktionen\n- Konstanten\n- Typen\n\n## Reader-Verhalten: Case\n\n- Der Reader wandelt **unescaped Buchstaben in UPPERCASE** um.  \n  `foo`, `Foo`, `FOO` → Symbol `FOO`\n\n### Escaped Symbole\n\n```lisp\n\\f\\o\\o   ; symbol \"foo\"\n|foo|    ; symbol \"foo\"\n```\n\n→ anders als `FOO`.\n\n## Ungültige Zeichen (ohne Escape)\n\n```\n() \"'`,;:|\n```\n\nDiese können mit `\\` oder `|...|` dennoch in Symbolnamen erscheinen.\n\n## Interning\n\nDer Reader sorgt dafür, dass **der gleiche Name immer dasselbe Symbolobjekt darstellt**.\n\n## Konventionen\n\n- `*global-variable*`\n- `+constant+`\n- `hello-world`\n- `%internal-helper`\n\n## Siehe auch\n\n- [Strings in Common Lisp](./20251210-130003_string-clisp.md)\n- [Zahlen in Common Lisp](./20251210-130002_numbers-clisp.md)\n"
    },
    {
      "id": "20251210-130005",
      "title": "Beispiele zusammengesetzter S-Expressions",
      "summary": "",
      "tags": [
        "commonlisp",
        "syntax",
        "examples"
      ],
      "group": "commonlisp",
      "size": 5,
      "file": "20251210-130005_nested-s-expressions-clisp.md",
      "refs": [
        {
          "text": "S-Expressions: Listen & Atome",
          "href": "./20251210-130001_s-expressions-lists-atoms.md",
          "file": "20251210-130001_s-expressions-lists-atoms.md",
          "targetId": "20251210-130001"
        }
      ],
      "raw": "---\nID: 20251210-130005\nTAGS: commonlisp, syntax, examples\n---\n# Beispiele zusammengesetzter S-Expressions\n\n## Einfache Beispiele\n\n```lisp\n()\n(1 2 3)\n(\"foo\" \"bar\")\n(x y z)\n(x 1 \"foo\")\n```\n\n## Typische Funktionsform\n\n```lisp\n(+ (* 2 3) 4)\n```\n\n## Beispiel: Funktionsdefinition\n\n```lisp\n(defun hello-world ()\n  (format t \"hello, world\"))\n```\n\n→ syntaktisch nur eine Liste mit:\n\n1. Symbol `DEFUN`  \n2. Symbol `HELLO-WORLD`  \n3. Parameterliste  \n4. Body\n\n## Siehe auch\n\n- [S-Expressions: Listen & Atome](./20251210-130001_s-expressions-lists-atoms.md)\n\n"
    }
  ],
  "links": [
    {
      "source": "20251209-001700",
      "target": "20251210-130001"
    },
    {
      "source": "20251209-001700",
      "target": "20251210-130002"
    },
    {
      "source": "20251209-001700",
      "target": "20251210-130003"
    },
    {
      "source": "20251209-001700",
      "target": "20251210-130004"
    },
    {
      "source": "20251209-001700",
      "target": "20251210-130005"
    },
    {
      "source": "20251209-001700",
      "target": "20251209-001800"
    },
    {
      "source": "20251209-001700",
      "target": "20251209-085400"
    },
    {
      "source": "20251209-001700",
      "target": "20251209-085500"
    },
    {
      "source": "20251209-001700",
      "target": "20251209-085900"
    },
    {
      "source": "20251209-001700",
      "target": "20251209-090400"
    },
    {
      "source": "20251209-001700",
      "target": "20251209-091201"
    },
    {
      "source": "20251209-001700",
      "target": "20251209-091200"
    },
    {
      "source": "20251209-001700",
      "target": "20251209-091500"
    },
    {
      "source": "20251209-001700",
      "target": "20251210-080300"
    },
    {
      "source": "20251209-001700",
      "target": "20251210-080100"
    },
    {
      "source": "20251209-001700",
      "target": "20251210-080200"
    },
    {
      "source": "20251209-001700",
      "target": "20251210-080400"
    },
    {
      "source": "20251209-091200",
      "target": "20251209-091500"
    },
    {
      "source": "20251209-091201",
      "target": "20251209-001800"
    },
    {
      "source": "20251209-091201",
      "target": "20251209-085400"
    },
    {
      "source": "20251209-091500",
      "target": "20251209-091200"
    },
    {
      "source": "20251210-080100",
      "target": "20251210-080200"
    },
    {
      "source": "20251210-080100",
      "target": "20251210-080400"
    },
    {
      "source": "20251210-080200",
      "target": "20251210-080100"
    },
    {
      "source": "20251210-080200",
      "target": "20251210-080400"
    },
    {
      "source": "20251210-080300",
      "target": "20251209-091500"
    },
    {
      "source": "20251210-080300",
      "target": "20251209-091200"
    },
    {
      "source": "20251210-080400",
      "target": "20251210-080100"
    },
    {
      "source": "20251210-080400",
      "target": "20251210-080200"
    },
    {
      "source": "20251210-080400",
      "target": "20251210-080300"
    },
    {
      "source": "20251210-130001",
      "target": "20251210-130002"
    },
    {
      "source": "20251210-130001",
      "target": "20251210-130003"
    },
    {
      "source": "20251210-130001",
      "target": "20251210-130004"
    },
    {
      "source": "20251210-130002",
      "target": "20251210-130001"
    },
    {
      "source": "20251210-130002",
      "target": "20251210-130004"
    },
    {
      "source": "20251210-130003",
      "target": "20251210-130004"
    },
    {
      "source": "20251210-130003",
      "target": "20251210-130001"
    },
    {
      "source": "20251210-130004",
      "target": "20251210-130003"
    },
    {
      "source": "20251210-130004",
      "target": "20251210-130002"
    },
    {
      "source": "20251210-130005",
      "target": "20251210-130001"
    }
  ]
}
